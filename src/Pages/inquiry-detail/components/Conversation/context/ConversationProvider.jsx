import React, {
    useRef,
    useState,
    useEffect,
    useContext,
    useCallback,
} from "react";
import { useIntl } from "react-intl";
import { useDispatch, useSelector } from "react-redux";

import { useSocketContext } from "@components/socket/SocketProvider";

import { SnackBar } from "@utils/toast";
import { getRandomString } from "@utils/stringHelpers";
import { userSelector } from "@store/authSlice/selectors";
import { convoRelatedModalSelector } from "@store/extraSlice/selectors";
import { setConvoDetails, toggleConvoRelatedModal } from "@store/extraSlice";
import { convoImageFromMembers, convoNameFromMembers } from "@utils/convoUtils";

const defSendStatus = {
    error: null,
    status: null,
    scroll: true,
    loading: false,
};

const defConvoUpdate = {
    name: "",
    image: "",
    error: null,
    type: null,
    status: null,
    loading: false,
    isAutoGenerated: false,
};

const ConvoUpdateMsg = {
    MADE_ADMIN: "admin_added_successfully",
    MEMBER_LEFT: "group_left_successfully",
    MEMBER_ADDED: "members_added_successfully",
    MEMBER_REMOVED: "member_removed_successfully",
    GROUP_NAME_CHANGED: "chat_name_changed_successfully",
    GROUP_IMAGE_CHANGED: "chat_image_changed_successfully",
};

const ConversationContext = React.createContext(null);
const ConversationProvider = (props) => {
    const {
        type,
        msgs,
        count,
        isAdmin,
        members,
        children,
        isActive,
        setMessages,
        conversationId,
        convoName: cName,
        convoImage: cImage,
    } = props;

    const dispatch = useDispatch();

    const { formatMessage } = useIntl();
    const { socket } = useSocketContext();

    const user = useSelector(userSelector);
    const convoModal = useSelector(convoRelatedModalSelector);
    const convoRef = useRef();

    // const userIdRef = useRef<number | null>(user?.id || null);

    const uniqueIdRef = useRef(`${type}-${conversationId}` || null);

    const [reply, setReply] = useState(null);
    const [participants, setParticipants] = useState(members);
    const [sendStatus, setSendStatus] = useState(defSendStatus);
    const [convoUpdate, setConvoUpdate] = useState({
        ...defConvoUpdate,
        name: cName || "",
        image: cImage || "",
        isAutoGenerated: !Boolean(cName),
    });

    useEffect(() => {
        if (!cName && convoUpdate.isAutoGenerated === true) {
            const mmb = Object.values(participants);
            setConvoUpdate((o) => ({
                ...o,
                isAutoGenerated: true,
                name: convoNameFromMembers(mmb, user?.email),
                image: convoImageFromMembers(mmb, user?.email, cImage),
            }));
        }
    }, [cName, participants, user?.email, cImage]);

    useEffect(() => {
        if (!socket?.id) return;

        const initSocket = () => {
            console.info("================================");
            console.info(`initSocket on ConversationProvider => ${socket?.id}`);
            console.info({ uid: uniqueIdRef.current, conversationId, type });
            console.info({ msgs, lastMsg: msgs?.[msgs?.length - 1] });
            console.info("================================");

            socket?.emit("join_conversation", {
                conversation_type: type,
                conversation_id: conversationId,
            });

            socket?.emit("event:message_seen", {
                user_email: user?.email,
                conversation_type: type,
                conversation_id: conversationId,
                message_id: msgs?.[msgs?.length - 1]?.message_id,
            });

            socket?.on(`message_seen_update`, onMessageSeen);
            socket?.on(`${uniqueIdRef?.current}-message`, onMessageRec);
            socket?.on(
                `${uniqueIdRef?.current}-message-update`,
                onMessageUpdate
            );
            socket?.on(
                `${uniqueIdRef?.current}-message-delete`,
                onMessageDelete
            );
            socket?.on(`${uniqueIdRef?.current}-reaction`, onMessageReacted);
            socket?.on(
                `${uniqueIdRef?.current}-group-update`,
                onConvoRelatedUpdate
            );
        };

        initSocket();
        setSendStatus(defSendStatus);

        return () => {
            const exitSocket = () => {
                socket?.off("message_seen_update", onMessageSeen);
                socket?.off(`${uniqueIdRef?.current}-message`, onMessageRec);
                socket?.off(
                    `${uniqueIdRef?.current}-message-update`,
                    onMessageUpdate
                );
                socket?.off(
                    `${uniqueIdRef?.current}-message-delete`,
                    onMessageDelete
                );
                socket?.off(
                    `${uniqueIdRef?.current}-reaction`,
                    onMessageReacted
                );
                socket?.off(
                    `${uniqueIdRef?.current}-group-update`,
                    onConvoRelatedUpdate
                );

                socket?.emit("leave_conversation", uniqueIdRef.current);
            };
            exitSocket();
        };
    }, [socket?.id]);

    const callNotify = (msg, type = "warning", params = {}) => {
        const message = formatMessage({ id: msg }, params);
        SnackBar({ message, doNotTranslate: true }, type);
    };

    const sendMessage = useCallback(
        (msg) => {
            if (socket) {
                const send = {
                    ...msg,
                    conversation_type: type,
                    sender_email: user?.email,
                    conversation_id: conversationId,
                    message_id:
                        reply?.type === "edit" ? reply?.message_id : undefined,
                    replied_message_id:
                        reply?.type === "edit" ? undefined : reply?.message_id,
                };
                const eventName = `event:${
                    reply?.type === "edit" ? "update_message" : "message"
                }`;
                console.info("Send Message", eventName, send);
                socket?.emit(eventName, send);
                setSendStatus({ ...defSendStatus, loading: true });
            } else {
                console.error("Socket connection not available.");
                callNotify("socket_connection_error", "error", { error: "" });
            }
        },
        [socket, reply]
    );

    const onMessageRec = useCallback((msg) => {
        console.info("onMessageRec", msg);
        setMessages?.((v) => [...v, msg]);
        setSendStatus((v) => ({ ...v, status: "success", loading: false }));
    }, []);

    const onMessageSeen = useCallback((msg) => {
        console.info("onMessageSeen", msg, participants);
        setParticipants((v) => {
            const obj = { ...v };
            msg?.user_email?.map((x) => {
                obj[x] = {
                    ...obj[x],
                    seen_at: msg.seen_at,
                    seen_message_id: msg.message_id,
                };
                return x;
            });
            return obj;
        });
    }, []);

    const onMessageUpdate = useCallback(
        (msg) => {
            console.info("From Server Msg onMessageUpdate", msg);

            setMessages?.((o) => {
                const idx = o.findIndex((x) =>
                    checkMessageIdSame(
                        x.message_id,
                        msg.message_id,
                        msg.temporary_id
                    )
                );
                if (idx === -1) return o;
                const msgs = [...o];
                msgs[idx] = {
                    ...o[idx],
                    is_edited: true,
                    message: msg.message,
                };
                return msgs;
            });
            setSendStatus((v) => ({
                ...v,
                status: "success",
                loading: false,
                scroll: false,
            }));
        },
        [setMessages]
    );

    const deleteMessage = useCallback(
        ({ message_id, delete_type }) => {
            if (socket) {
                const deleteMessage = {
                    message_id,
                    delete_type,
                    conversation_type: type,
                    sender_email: user?.email,
                    conversation_id: conversationId,
                };
                socket?.emit("event:delete_message", deleteMessage);
                setSendStatus((v) => ({
                    ...v,
                    status: "success",
                    loading: false,
                    scroll: false,
                }));
            } else {
                console.error("Socket connection not available.");
                callNotify("socket_connection_error", "error", { error: "" });
            }
        },
        [socket]
    );

    const onMessageDelete = useCallback(
        (msg) => {
            console.info("From Server Msg onMessageDelete", msg);
            setMessages?.((o) => {
                const messageIndex = o.findIndex((x) =>
                    checkMessageIdSame(
                        x.message_id,
                        msg.message_id,
                        msg.temporary_id
                    )
                );
                if (messageIndex === -1) return o;
                const updatedMessages = [...o];
                if (msg.delete_type === "self") {
                    updatedMessages.splice(messageIndex, 1); // Remove the message
                } else {
                    // Mark the message as deleted
                    updatedMessages[messageIndex] = {
                        ...o[messageIndex],
                        is_deleted: true,
                        message: "",
                    };
                }
                return updatedMessages;
            });
            setSendStatus({
                ...defSendStatus,
                status: "success",
                scroll: false,
            });
        },
        [setMessages, setSendStatus]
    );

    const onReactToMessage = useCallback(
        ({ message_id, reaction, reaction_type }) => {
            console.info(
                "From client to server onReactToMessage",
                message_id,
                reaction
            );
            socket?.emit("event:react_message", {
                reaction,
                message_id,
                reaction_type,
                conversation_type: type,
                // user_email: user?.email,
                conversation_id: conversationId,
            });
        },
        [socket]
    );

    const onMessageReacted = useCallback(
        (data) => {
            console.info("onMessageReacted", data);

            setMessages?.((msgs) => {
                const idx = msgs.findIndex((m) => {
                    return checkMessageIdSame(
                        m.message_id,
                        data.message_id,
                        data.temporary_id
                    );
                });

                if (idx === -1) return msgs; // Exit if message not found

                const reactions = msgs[idx]?.reactions || [];

                let updatedReactions = [];

                if (data.reaction_type === "add") {
                    // Add the new reaction
                    updatedReactions = [...reactions, data];
                } else if (data.reaction_type === "delete") {
                    // Remove the reaction for the specified user
                    updatedReactions = reactions.filter(
                        (r) => r.user_email !== data.user_email
                    );
                } else if (data.reaction_type === "update") {
                    // Update the reaction for the specified user
                    updatedReactions = reactions.map((r) =>
                        r.user_email === data.user_email
                            ? { ...r, reaction: data.reaction }
                            : r
                    );
                } else {
                    // Default case (unchanged reactions)
                    updatedReactions = reactions;
                }

                // Return updated messages array
                return msgs.map((m, i) =>
                    i === idx ? { ...m, reactions: updatedReactions } : m
                );
            });
        },
        [setMessages]
    );

    const callUpdateConvoEvent = (payloadEventPayload) => {
        if (socket && payload.update_type) {
            const adminEmail = Object.values(participants).find(
                (i) => i.role === "admin"
            )?.email;
            convoRef.current = {
                ...convoRef.current,
                new_members:
                    payload.update_type === "MEMBER_ADDED"
                        ? payload.new_members
                        : undefined,
                adminEmail,
            };

            setConvoUpdate((o) => ({
                ...o,
                adminEmail,
                loading: true,
                type: payload.update_type,
            }));
            socket.emit("event:group_update", {
                ...payload,
                conversation_type: type,
                conversation_id: conversationId,
            });
        }
    };

    const onConvoRelatedUpdate = useCallback((resEventResponse) => {
        console.info("From Socket Server Msg onConvoRelatedUpdate", {
            res,
        });

        // Handle member left event - no state mutation needed
        res.update_type === "MEMBER_LEFT" &&
            convoModal?.from !== "list" &&
            router.push(`/inquiry`);

        // Remove member
        res.update_type === "MEMBER_REMOVED" &&
            setParticipants((o) =>
                res?.affected_user_email &&
                typeof res.affected_user_email === "string"
                    ? (delete o[res.affected_user_email], o)
                    : { ...o }
            );

        // Add members
        res.update_type === "MEMBER_ADDED" &&
            typeof res.affected_user_email !== "string" &&
            setParticipants((o) => {
                let n = { ...o };
                (convoRef.current?.new_members || []).map((i) => {
                    n[i.email] = { ...i, role: "member" };
                });
                return n;
            });

        // Update roles immutably
        res.update_type === "MADE_ADMIN" &&
            setParticipants((o) => {
                if (
                    !res?.affected_user_email ||
                    typeof res.affected_user_email !== "string"
                )
                    return { ...o };
                return {
                    ...o,
                    [res.affected_user_email]: {
                        ...o[res.affected_user_email],
                        role: "admin",
                    },
                    ...(convoRef.current?.adminEmail &&
                    o[convoRef.current?.adminEmail]
                        ? {
                              [convoRef.current?.adminEmail]: {
                                  ...o[convoRef.current?.adminEmail],
                                  role: "member",
                              },
                          }
                        : {}),
                };
            });

        // Update convo state immutably
        setConvoUpdate((o) => {
            const obj = {
                ...o,
                loading: false,
                status: "success",
            };
            if (o.type !== res.update_type) return obj;
            return {
                ...obj,
                ...(o.type === "GROUP_NAME_CHANGED"
                    ? { name: res?.new_group_name }
                    : {}),
                ...(o.type === "GROUP_IMAGE_CHANGED"
                    ? { image: res?.new_group_image }
                    : {}),
                // ...(o.type === "MEMBER_ADDED" ? { new_members: undefined } : {}),
            };
        });

        // Show notification and trigger updates
        SnackBar(
            {
                message: formatMessage({ id: ConvoUpdateMsg[res.update_type] }),
                doNotTranslate: true,
            },
            "success"
        );
        dispatch(toggleConvoRelatedModal(null)); // Close modals
        dispatch(setConvoDetails({ fetchConvo: true })); // Fetch updated convo

        // Update messages immutably
        setMessages((o) => {
            let r = {
                timestamp: Date.now(),
                message_id: getRandomString(),
                ...res,
            };
            return !res.affected_user_email ||
                typeof res.affected_user_email === "string"
                ? [...o, r]
                : [
                      ...o,
                      ...res.affected_user_email.map((i) => ({
                          ...r,
                          affected_user_email: i,
                      })),
                  ];
        });
    }, []);

    return (
        <ConversationContext.Provider
            value={{
                msgs,
                type,
                reply,
                count,
                isAdmin,
                isActive,
                setReply,
                sendStatus,
                sendMessage,
                convoUpdate,
                deleteMessage,
                setSendStatus,
                conversationId,
                setConvoUpdate,
                onReactToMessage,
                callUpdateConvoEvent,
                members: participants,
                setMembers: setParticipants,
            }}
        >
            {children}
        </ConversationContext.Provider>
    );
};

const useConversationSocket = () => {
    const context = useContext(ConversationContext);
    if (!context) throw new Error(`useConversationSocket is undefined`);

    return context;
};

export { useConversationSocket, ConversationProvider };
const checkMessageIdSame = (m, d, t) => `${t}` === `${m}` || `${d}` === `${m}`;
